#1. ui folder:
Will contain reusable UI components (like: buttons, inputs...).
Mostly they are just presentational and don't contain side effects.

#2. services folder:     
This folder is for reusable code for interacting with API.

#3. utils folder: 
These are helper functions that we can also reuse in multiple places of the application.
Reusable and stateless helper functions that don't create any side effects (like: date or number manipulations...).

#4 A whole new way of Routing:
This is the recommended router for all React Router web projects to work with powerful APIs like Data Loader, Data Actions or Data Fetchers.

Example: App.jsx

#5. Architecture of App Layout:
So, the Header and Footer would stay the same across the whole application, only Main will change according to pages (like: Cart, Menu or Order...).

#6. Nested Routes:
The AppLayout.jsx is a 'parent Route' of all routes, inside it we have <Outlet /> which is the placeholder for 'child routes'. The 'child routes' are in the 'children' property of the 'router'. Now they are nested routes.

<AppLayout /> - since it doesn't have a 'path', it is technically called 'Layout Route'.

Example: App.jsx file

#7. Fetching data with React Router:
Three steps:
1. create a loader function
2. connect the loader function with the route
3. provide the data to the component (page) (by using custom hook => useLoaderData())

useLoaderData() - helps to get the data into the component.

'loader' is for reading data.
'loader' can be placed anywhere in the code base, but convention is to place loader for the data of the certain page inside the file of that page. Loader function must return whatever data it wants to provide to a page.

The concept is - rendering a page and fetching data happens at the same time.

Example: step_1. Menu.jsx, step_2. App.jsx, step_3. Menu.jsx

#8. Global Navigation State:
useNavigation() - shows a global loading indicator, no matter what data is being loaded.

Better to place in 'navigation.state' in AppLayout.jsx so to make it universal for entire application.

Example: AppLayout.jsx file

#9. Handling Errors with Error Elements:
The errors that happen in the 'nested routes', they will bubble up to the 'parent route'.

To get the actual error message that happened inside React Router => useRouteError().
The Error.jsx component gets the access to the error happened.

Example: App.jsx and Error.jsx

#10. Fetching Orders:
To get the id from URL right into getOrder() function in Order.jsx, don't use useParams() as it does work only in components. React Router passes some data in 'loader' function, and one of properties of the object that 'loader' receives is 'params'.

'params.orderID' is because we gave the name 'orderID' in routes of <Order />, App.jsx file.

Example: Order.jsx

#11. Writing Data with React Router 'Actions':
'Actions' are used to write or mutate data, so the state that is stored on some server.
Or in other words, 'actions' allow us to manage this remote server state using 'action' functions and 'form' that we then wire up to routes similar to what we did earlier with the 'loader'.

Whenever this <Form>...</Form> will be submitted, behind the scenes React Router will then call this 'action' function and it'll pass the request that was submitted.

Connected this 'action' with "/order/new" route in App.jsx. Whenever there will be a new form submission on this "/order/new" route, the 'action' that we specified will be called. 

So this makes easy to get the data out of the form into 'action' function.

Example: CreateOrder.jsx and connected in App.jsx